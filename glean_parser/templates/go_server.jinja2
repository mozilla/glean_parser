{# The final Go code is autogenerated, but this template is not. Please file bugs! #}
package glean

// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// AUTOGENERATED BY glean_parser v{{ parser_version }}. DO NOT EDIT.

// required imports
import (
{% if transport == "pubsub" %}
    "context"
    "encoding/json"
    "fmt"
    "log"
    "sync"
    "sync/atomic"
    "time"

    "cloud.google.com/go/pubsub"
    "github.com/google/uuid"
{% else %}
    "encoding/json"
    "errors"
    "fmt"
    "io"
    "strconv"
    "time"

    "github.com/google/uuid"
{% endif %}
)

{% if transport == "logging" %}
// log type string used to identify logs to process in the Moz Data Pipeline
var gleanEventMozlogType string = "glean-server-event"

// A GleanEventsLogger produces output in the required format for Glean to ingest.
// Glean ingestion requires the output to be written to os.Stdout. Writing to a different
// output will require the consumer to handle any closing as appropriate for the Writer.
// e.g. if writing to a file.
type GleanEventsLogger struct {
    AppID             string // Application Id to identify application per Glean standards
    AppDisplayVersion string // Version of application emitting the event
    AppChannel        string // Channel to differentiate logs from prod/beta/staging/devel
    Writer            io.Writer // Writer to output to. Normal operation expects os.Stdout
}
{% else %}
// GleanEventsPublisher publishes Glean events directly to Pub/Sub
type GleanEventsPublisher struct {
    AppID             string // Application ID to identify application per Glean standards
    AppDisplayVersion string // Version of application emitting the event
    AppChannel        string // Channel to differentiate logs from prod/beta/staging/devel

    topic          *pubsub.Topic
    ctx            context.Context
    publishedCount atomic.Int64
    errorCount     atomic.Int64
    pendingResults chan *pubsub.PublishResult
    wg             sync.WaitGroup
    once           sync.Once
}
{% endif %}

// exported type for public method parameters
type RequestInfo struct {
    UserAgent string
    IpAddress string
}

// default empty values will be omitted in json from ping struct definition
var defaultRequestInfo = RequestInfo{
    UserAgent: "",
    IpAddress: "",
}

// structs to construct the glean ping
type clientInfo struct {
    TelemetrySDKBuild string `json:"telemetry_sdk_build"`
    FirstRunDate      string `json:"first_run_date"`
    OS                string `json:"os"`
    OSVersion         string `json:"os_version"`
    Architecture      string `json:"architecture"`
    AppBuild          string `json:"app_build"`
    AppDisplayVersion string `json:"app_display_version"`
    AppChannel        string `json:"app_channel"`
}

type pingInfo struct {
    Seq       int    `json:"seq"`
    StartTime string `json:"start_time"`
    EndTime   string `json:"end_time"`
}

type ping struct {
    DocumentNamespace string `json:"document_namespace"`
    DocumentType      string `json:"document_type"`
    DocumentVersion   string `json:"document_version"`
    DocumentID        string `json:"document_id"`
    UserAgent         string `json:"user_agent,omitempty"`
    IpAddress         string `json:"ip_address,omitempty"`
    Payload           string `json:"payload"`
}

type metrics map[string]map[string]interface{}

type pingPayload struct {
    ClientInfo clientInfo   `json:"client_info"`
    PingInfo   pingInfo     `json:"ping_info"`
    Metrics    metrics      `json:"metrics"`
    Events     []gleanEvent `json:"events"`
}

type gleanEvent struct {
    Category  string            `json:"category"`
    Name      string            `json:"name"`
    Timestamp int64             `json:"timestamp"`
    Extra     map[string]string `json:"extra"`
}

{% if transport == "logging" %}
type logEnvelope struct {
    Timestamp string
    Logger    string
    Type      string
    Fields    ping
}
{% endif %}

{% if transport == "pubsub" %}
func (g *GleanEventsPublisher) createClientInfo() clientInfo {
{% else %}
func (g GleanEventsLogger) createClientInfo() clientInfo {
{% endif %}
    // Fields with default values are required in the Glean schema, but not used in server context
    return clientInfo{
        TelemetrySDKBuild: "glean_parser v{{ parser_version }}",
        FirstRunDate:      "Unknown",
        OS:                "Unknown",
        OSVersion:         "Unknown",
        Architecture:      "Unknown",
        AppBuild:          "Unknown",
        AppDisplayVersion: g.AppDisplayVersion,
        AppChannel:        g.AppChannel,
    }
}

func createPingInfo() pingInfo {
    {# times are ISO-8601 strings, e.g. "2023-12-19T22:09:17.440Z" #}
    now := time.Now().UTC().Format("2006-01-02T15:04:05.000Z")
    return pingInfo{
        Seq:       0,
        StartTime: now,
        EndTime:   now,
    }
}

{% if transport == "pubsub" %}
func (g *GleanEventsPublisher) createPing(documentType string, config RequestInfo, payload pingPayload) (ping, error) {
{% else %}
func (g GleanEventsLogger) createPing(documentType string, config RequestInfo, payload pingPayload) (ping, error) {
{% endif %}
    payloadJson, err := json.Marshal(payload)
    if err != nil {
        return ping{}, err
    }

    documentID, err := uuid.NewRandom()
    if err != nil {
        return ping{}, err
    }

    return ping{
        DocumentNamespace: g.AppID,
        DocumentType:      documentType,
        DocumentVersion:   "1",
        DocumentID:        documentID.String(),
        UserAgent:         config.UserAgent,
        IpAddress:         config.IpAddress,
        Payload:           string(payloadJson),
    }, nil
}

{% if transport == "pubsub" %}
// Stats holds publishing statistics
type Stats struct {
    Published int64
    Errors    int64
}

// NewGleanEventsPublisher creates a new Pub/Sub-based Glean events publisher
// Authentication uses Application Default Credentials (ADC) - typically GKE Workload Identity
func NewGleanEventsPublisher(ctx context.Context, projectID, topicID, appID, appDisplayVersion, appChannel string) (*GleanEventsPublisher, error) {
    // Create Pub/Sub client using Application Default Credentials
    client, err := pubsub.NewClient(ctx, projectID)
    if err != nil {
        return nil, fmt.Errorf("failed to create pubsub client: %w", err)
    }

    topic := client.Topic(topicID)

    // Configure publish settings following Pub/Sub best practices for high throughput
    // https://cloud.google.com/pubsub/docs/publish-best-practices
    topic.PublishSettings = pubsub.PublishSettings{
        CountThreshold: 1000,
        ByteThreshold:  10e6,
        DelayThreshold: 100 * time.Millisecond,

        // Flow control prevents memory exhaustion when producing faster than publishing
        FlowControlSettings: pubsub.FlowControlSettings{
            MaxOutstandingMessages: 100000,
            MaxOutstandingBytes:    200e6,
            LimitExceededBehavior:  pubsub.FlowControlBlock, // Block Publish() calls when limit exceeded (backpressure)
        },
    }

    publisher := &GleanEventsPublisher{
        AppID:             appID,
        AppDisplayVersion: appDisplayVersion,
        AppChannel:        appChannel,
        topic:             topic,
        ctx:               ctx,
        pendingResults:    make(chan *pubsub.PublishResult, 10000), // Buffer for pending results
    }

    // Start background goroutine to process publish results asynchronously
    publisher.wg.Add(1)
    go publisher.processResults()

    return publisher, nil
}

// processResults runs in background to handle publish results asynchronously
func (g *GleanEventsPublisher) processResults() {
    defer g.wg.Done()

    for result := range g.pendingResults {
        // Get() blocks until the publish completes or fails
        _, err := result.Get(g.ctx)
        if err != nil {
            g.errorCount.Add(1)
            // Log error but don't block on I/O
            log.Printf("Pub/Sub publish error: %v", err)
        } else {
            g.publishedCount.Add(1)
        }
    }
}

// construct the Glean envelope and publish to Pub/Sub asynchronously
func (g *GleanEventsPublisher) publish(
    documentType string,
    requestInfo RequestInfo,
    metrics metrics,
    events []gleanEvent,
) error {
    var telemetryPayload = pingPayload{
        ClientInfo: g.createClientInfo(),
        PingInfo:   createPingInfo(),
        Metrics:    metrics,
        Events:     events,
    }

    ping, err := g.createPing(documentType, requestInfo, telemetryPayload)
    if err != nil {
        return fmt.Errorf("failed to create ping: %w", err)
    }

    var envelope = ping

    envelopeJSON, err := json.Marshal(envelope)
    if err != nil {
        return fmt.Errorf("failed to marshal envelope: %w", err)
    }

    // Publish message asynchronously
    // Publish() returns immediately with a PublishResult future
    result := g.topic.Publish(g.ctx, &pubsub.Message{
        Data: envelopeJSON,
    })

    // Send result to background processor (non-blocking if channel has space)
    select {
    case g.pendingResults <- result:
        // Successfully queued
        return nil
    case <-g.ctx.Done():
        // Context cancelled
        return g.ctx.Err()
    }
}

// Stats returns current publishing statistics
func (g *GleanEventsPublisher) Stats() Stats {
    return Stats{
        Published: g.publishedCount.Load(),
        Errors:    g.errorCount.Load(),
    }
}

// Flush waits for all pending publish operations to complete
// Call this before shutdown to ensure no messages are lost
func (g *GleanEventsPublisher) Flush() {
    log.Println("Flushing pending publishes...")

    // Stop accepting new messages and flush pending batches
    g.topic.Stop()

    // Close results channel to signal background processor to finish
    g.once.Do(func() {
        close(g.pendingResults)
    })

    // Wait for background processor to finish
    g.wg.Wait()

    stats := g.Stats()
    log.Printf("Flush complete. Published: %d, Errors: %d", stats.Published, stats.Errors)
}

// Close performs graceful shutdown, flushing all pending messages
func (g *GleanEventsPublisher) Close() error {
    g.Flush()
    return nil
}
{% else %}
// method called by each ping-specific record method.
// construct the ping, wrap it in the envelope, and print to stdout
func (g GleanEventsLogger) record(
    documentType string,
    requestInfo RequestInfo,
    metrics metrics,
    events []gleanEvent,
) error {
    if g.Writer == nil {
        return errors.New("writer not specified")
    }

    telemetryPayload := pingPayload{
        ClientInfo: g.createClientInfo(),
        PingInfo:   createPingInfo(),
        Metrics:    metrics,
        Events:     events,
    }

    ping, err := g.createPing(documentType, requestInfo, telemetryPayload)
    if err != nil {
        return err
    }

    envelope := logEnvelope{
        Timestamp: strconv.FormatInt(time.Now().UnixNano(), 10),
        Logger:    "glean",
        Type:      gleanEventMozlogType,
        Fields:    ping,
    }
    envelopeJson, err := json.Marshal(envelope)
    if err != nil {
        return err
    }

    fmt.Fprintln(g.Writer, string(envelopeJson))
    return nil
}
{% endif %}
{# if any ping has an event metric, create methods and types for them #}
{% if events %}

func newGleanEvent(category, name string, extra map[string]string) gleanEvent {
    return gleanEvent{
        Category:  category,
        Name:      name,
        Timestamp: time.Now().UnixMilli(),
        Extra: extra,
    }
}
{# each event has a type and method to create a gleanEvent #}
{% for event in events %}

type {{ event|event_type_name }} struct {
    {% for extra, metadata in event.extra_keys.items() %}
    {{ extra|event_extra_name }} {{ metadata.type|go_metric_type }} // {{ metadata.description|clean_string }}
    {% endfor %}
}

func (e {{ event|event_type_name }}) gleanEvent() gleanEvent {
    return newGleanEvent(
        "{{ event.category }}",
        "{{ event.name }}",
        map[string]string{
        {% for extra, metadata in event.extra_keys.items() %}
            {# convert all extra fields to string for submission #}
            {% if metadata.type == 'boolean' %}
            "{{ extra }}": fmt.Sprintf("%t", e.{{ extra|event_extra_name }}),
            {% elif metadata.type == 'quantity' %}
            "{{ extra }}": fmt.Sprintf("%d", e.{{ extra|event_extra_name }}),
            {% else %}
            "{{ extra }}": e.{{ extra|event_extra_name }},
            {% endif %}
        {% endfor %}
        },
    )
}
{% endfor %}
{% endif %}
{# struct & methods for submitting pings #}
{% for ping, metrics_by_type in pings.items() %}
{% if metrics_by_type['event'] %}

{# interface that eligible events for this ping will implement #}
type {{ ping|ping_events_type_name }} interface {
    is{{ping|ping_events_type_name }}()
    gleanEvent() gleanEvent
}

{# create functions for valid events for this ping #}
{% for metric in metrics_by_type['event'] %}
func (e {{ metric|event_type_name}}) is{{ ping|ping_events_type_name }}() {}
{% endfor %}
{% endif %}

type {{ ping|ping_type_name }} struct {
    {% for metric_type, metrics in metrics_by_type.items() %}
    {% if metric_type != 'event' %}
    {% for metric in metrics %}
    {{ metric|metric_argument_name }} {{ metric_type|go_metric_type}} // {{ metric.description|clean_string }}
    {% endfor %}
    {% endif %}
    {% endfor %}
    {% if metrics_by_type['event'] %}
    Event {{ ping|ping_events_type_name }} // valid event for this ping
    {% endif %}
}

// Record and submit `{{ ping }}` ping
{% if transport == "pubsub" %}
func (g *GleanEventsPublisher) Record{{ ping|ping_type_name }}(
{% else %}
func (g GleanEventsLogger) Record{{ ping|ping_type_name }}(
{% endif %}
    requestInfo RequestInfo,
    params {{ ping|ping_type_name }},
) error {
    metrics := metrics{
    {% for metric_type, metrics in metrics_by_type.items() %}
    {% if metric_type != 'event' %}
        "{{ metric_type }}": {
        {% for metric in metrics %}
            {% if metric_type == 'datetime' %}
            "{{ metric|metric_name }}": params.{{ metric|metric_argument_name }}.Format("2006-01-02T15:04:05.000Z"),
            {% else %}
            "{{ metric|metric_name }}": params.{{ metric|metric_argument_name }},
            {% endif %}
        {% endfor %}
        },
    {% endif %}
    {% endfor %}
    }

    events := []gleanEvent{}
    {% if metrics_by_type['event'] %}
    if params.Event != nil {
        events = append(events, params.Event.gleanEvent())
    }
    {% endif %}
{% if transport == "pubsub" %}
    return g.publish("{{ ping }}", requestInfo, metrics, events)
{% else %}
    return g.record("{{ ping }}", requestInfo, metrics, events)
{% endif %}
}

// Record and submit `{{ ping }}` ping omitting user request info
{% if transport == "pubsub" %}
func (g *GleanEventsPublisher) Record{{ ping|ping_type_name}}WithoutUserInfo(
{% else %}
func (g GleanEventsLogger) Record{{ ping|ping_type_name}}WithoutUserInfo(
{% endif %}
    params {{ ping|ping_type_name}},
) error {
    return g.Record{{ ping|ping_type_name }}(defaultRequestInfo, params)
}
{% endfor %}
