package glean

// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

// AUTOGENERATED BY {current_version}. DO NOT EDIT.

// required imports
import (
    "bytes"
    "context"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "sync"
    "time"

    "github.com/google/uuid"
    "github.com/prometheus/client_golang/prometheus"
    "github.com/prometheus/client_golang/prometheus/promauto"
)

// Prometheus metrics for monitoring HTTP publishing
var (
    // Tracks API calls (RecordEventsPing calls - may queue if workers are slow)
    gleanPublishTotal = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "glean_http_publish_total",
            Help: "Total number of Glean events queued for publishing (API calls)",
        },
        []string{"app_id", "document_type", "status"},
    )

    // Tracks actual HTTP requests completed (the real throughput metric)
    gleanHTTPRequestsCompleted = promauto.NewCounterVec(
        prometheus.CounterOpts{
            Name: "glean_http_requests_completed",
            Help: "Actual HTTP requests completed over the network",
        },
        []string{"app_id", "document_type", "status"},
    )
)

// httpRequest tracks metadata for async HTTP operations
type httpRequest struct {
    url          string
    payload      []byte
    userAgent    string
    documentType string
    doneCh       chan error
}

// GleanEventsPublisher publishes Glean events via HTTP to ingestion endpoint
type GleanEventsPublisher struct {
    AppID             string // Application ID to identify application per Glean standards
    AppDisplayVersion string // Version of application emitting the event
    AppChannel        string // Channel to differentiate logs from prod/beta/staging/devel

    endpoint       string // HTTP endpoint URL (e.g., https://incoming.telemetry.mozilla.org/submit)
    client         *http.Client
    ctx            context.Context
    pendingReqs    chan *httpRequest
    wg             sync.WaitGroup
    once           sync.Once
    maxConcurrency int // Number of concurrent HTTP workers
}

// exported type for public method parameters
type RequestInfo struct {
    UserAgent string
    IpAddress string
}

// default empty values will be omitted in json from ping struct definition
var defaultRequestInfo = RequestInfo{
    UserAgent: "",
    IpAddress: "",
}

// structs to construct the glean ping
type clientInfo struct {
    TelemetrySDKBuild string `json:"telemetry_sdk_build"`
    FirstRunDate      string `json:"first_run_date"`
    OS                string `json:"os"`
    OSVersion         string `json:"os_version"`
    Architecture      string `json:"architecture"`
    AppBuild          string `json:"app_build"`
    AppDisplayVersion string `json:"app_display_version"`
    AppChannel        string `json:"app_channel"`
}

type pingInfo struct {
    Seq       int    `json:"seq"`
    StartTime string `json:"start_time"`
    EndTime   string `json:"end_time"`
}

type metrics map[string]map[string]interface{}

type pingPayload struct {
    ClientInfo clientInfo   `json:"client_info"`
    PingInfo   pingInfo     `json:"ping_info"`
    Metrics    metrics      `json:"metrics"`
    Events     []gleanEvent `json:"events"`
}

type gleanEvent struct {
    Category  string            `json:"category"`
    Name      string            `json:"name"`
    Timestamp int64             `json:"timestamp"`
    Extra     map[string]string `json:"extra"`
}

func (g *GleanEventsPublisher) createClientInfo() clientInfo {
    // Fields with default values are required in the Glean schema, but not used in server context
    return clientInfo{
        TelemetrySDKBuild: "{current_version}",
        FirstRunDate:      "Unknown",
        OS:                "Unknown",
        OSVersion:         "Unknown",
        Architecture:      "Unknown",
        AppBuild:          "Unknown",
        AppDisplayVersion: g.AppDisplayVersion,
        AppChannel:        g.AppChannel,
    }
}

func createPingInfo() pingInfo {
    now := time.Now().UTC().Format("2006-01-02T15:04:05.000Z")
    return pingInfo{
        Seq:       0,
        StartTime: now,
        EndTime:   now,
    }
}

// NewGleanEventsPublisher creates a new HTTP-based Glean events publisher
func NewGleanEventsPublisher(ctx context.Context, endpoint, appID, appDisplayVersion, appChannel string, concurrency int) (*GleanEventsPublisher, error) {
    if concurrency <= 0 {
        concurrency = 10 // Default concurrency
    }

    publisher := &GleanEventsPublisher{
        AppID:             appID,
        AppDisplayVersion: appDisplayVersion,
        AppChannel:        appChannel,
        endpoint:          endpoint,
        ctx:               ctx,
        pendingReqs:       make(chan *httpRequest, 10000),
        maxConcurrency:    concurrency,
        client: &http.Client{
            Timeout: 10 * time.Second,
            Transport: &http.Transport{
                MaxIdleConns:        1000,
                MaxIdleConnsPerHost: concurrency * 2,
                IdleConnTimeout:     90 * time.Second,
                DisableCompression:  false,
            },
        },
    }

    // Start background goroutines to process HTTP requests concurrently
    for i := 0; i < concurrency; i++ {
        publisher.wg.Add(1)
        go publisher.processHTTPRequests()
    }

    return publisher, nil
}

// processHTTPRequests runs in background to handle HTTP requests asynchronously
func (g *GleanEventsPublisher) processHTTPRequests() {
    defer g.wg.Done()

    for req := range g.pendingReqs {
        err := g.sendHTTPRequest(req)

        status := "success"
        if err != nil {
            status = "error"
            log.Printf("HTTP publish error: %v", err)
        }

        gleanPublishTotal.WithLabelValues(
            g.AppID,
            req.documentType,
            status,
        ).Inc()

        // Track actual HTTP request completion (the real throughput)
        gleanHTTPRequestsCompleted.WithLabelValues(
            g.AppID,
            req.documentType,
            status,
        ).Inc()

        // Notify caller if they're waiting
        if req.doneCh != nil {
            req.doneCh <- err
            close(req.doneCh)
        }
    }
}

// sendHTTPRequest performs the actual HTTP POST request
func (g *GleanEventsPublisher) sendHTTPRequest(req *httpRequest) error {
    httpReq, err := http.NewRequestWithContext(g.ctx, "POST", req.url, bytes.NewReader(req.payload))
    if err != nil {
        return fmt.Errorf("failed to create HTTP request: %w", err)
    }

    httpReq.Header.Set("Content-Type", "application/json")
    if req.userAgent != "" {
        httpReq.Header.Set("User-Agent", req.userAgent)
    }

    resp, err := g.client.Do(httpReq)
    if err != nil {
        return fmt.Errorf("HTTP request failed: %w", err)
    }
    defer resp.Body.Close()

    if resp.StatusCode < 200 || resp.StatusCode >= 300 {
        return fmt.Errorf("HTTP request failed with status %d", resp.StatusCode)
    }

    return nil
}

// construct the Glean payload and publish via HTTP asynchronously
func (g *GleanEventsPublisher) publish(
    documentType string,
    requestInfo RequestInfo,
    metrics metrics,
    events []gleanEvent,
) error {
    var telemetryPayload = pingPayload{
        ClientInfo: g.createClientInfo(),
        PingInfo:   createPingInfo(),
        Metrics:    metrics,
        Events:     events,
    }

    // Marshal the inner payload
    payloadJSON, err := json.Marshal(telemetryPayload)
    if err != nil {
        return fmt.Errorf("failed to marshal payload: %w", err)
    }

    // Generate document ID
    documentID, err := uuid.NewRandom()
    if err != nil {
        return fmt.Errorf("failed to generate document ID: %w", err)
    }

    // Construct URL following ingestion-edge format:
    // POST /submit/<namespace>/<docType>/<docVersion>/<docId>
    url := fmt.Sprintf("%s/%s/%s/%s/%s",
        g.endpoint,
        g.AppID,
        documentType,
        "1", // document version
        documentID.String(),
    )

    // Create HTTP request
    req := &httpRequest{
        url:          url,
        payload:      payloadJSON,
        userAgent:    requestInfo.UserAgent,
        documentType: documentType,
        doneCh:       nil, // Non-blocking async mode
    }

    // Send request to background workers (non-blocking if channel has space)
    select {
    case g.pendingReqs <- req:
        // Successfully queued
        return nil
    case <-g.ctx.Done():
        // Context cancelled
        return g.ctx.Err()
    }
}

// QueueDepth returns the current number of pending HTTP requests in the queue
func (g *GleanEventsPublisher) QueueDepth() int {
    return len(g.pendingReqs)
}

// Flush waits for all pending HTTP requests to complete
// Call this before shutdown to ensure no messages are lost
func (g *GleanEventsPublisher) Flush() {
    log.Println("Flushing pending HTTP requests...")

    // Close channel to signal workers to finish
    g.once.Do(func() {
        close(g.pendingReqs)
    })

    // Wait for all workers to finish
    g.wg.Wait()
    log.Println("All pending HTTP requests flushed.")
}

// Close performs graceful shutdown, flushing all pending messages
func (g *GleanEventsPublisher) Close() error {
    g.Flush()
    return nil
}

func newGleanEvent(category, name string, extra map[string]string) gleanEvent {
    return gleanEvent{
        Category:  category,
        Name:      name,
        Timestamp: time.Now().UnixMilli(),
        Extra:     extra,
    }
}

type BackendTestEventEvent struct {
    EventFieldString string // A string extra field
    EventFieldQuantity int64 // A quantity extra field
    EventFieldBool bool // A boolean extra field
}

func (e BackendTestEventEvent) gleanEvent() gleanEvent {
    return newGleanEvent(
        "backend",
        "test_event",
        map[string]string{
            "event_field_string": e.EventFieldString,
            "event_field_quantity": fmt.Sprintf("%d", e.EventFieldQuantity),
            "event_field_bool": fmt.Sprintf("%t", e.EventFieldBool),
        },
    )
}

type EventsPingEvent interface {
    isEventsPingEvent()
    gleanEvent() gleanEvent
}

func (e BackendTestEventEvent) isEventsPingEvent() {}

type EventsPing struct {
    MetricName string // Test string metric
    MetricRequestBool bool // boolean
    MetricRequestCount int64 // Test quantity metric
    MetricRequestDatetime time.Time // Test datetime metric
    MetricRequestStringList []string // Test string_list metric
    Event EventsPingEvent // valid event for this ping
}

// Record and submit `events` ping
func (g *GleanEventsPublisher) RecordEventsPing(
    requestInfo RequestInfo,
    params EventsPing,
) error {
    metrics := metrics{
        "string": {
            "metric.name": params.MetricName,
        },
        "boolean": {
            "metric.request_bool": params.MetricRequestBool,
        },
        "quantity": {
            "metric.request_count": params.MetricRequestCount,
        },
        "datetime": {
            "metric.request_datetime": params.MetricRequestDatetime.Format("2006-01-02T15:04:05.000Z"),
        },
        "string_list": {
            "metric.request_string_list": params.MetricRequestStringList,
        },
    }

    events := []gleanEvent{}
    if params.Event != nil {
        events = append(events, params.Event.gleanEvent())
    }
    return g.publish("events", requestInfo, metrics, events)
}

// Record and submit `events` ping omitting user request info
func (g *GleanEventsPublisher) RecordEventsPingWithoutUserInfo(
    params EventsPing,
) error {
    return g.RecordEventsPing(defaultRequestInfo, params)
}
